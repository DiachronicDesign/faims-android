import au.org.intersect.faims.android.data.User;
import au.org.intersect.faims.android.ui.form.EntityAttribute;
import au.org.intersect.faims.android.ui.form.RelationshipAttribute;
import java.util.List;
import java.util.Collection;
import au.org.intersect.faims.android.ui.form.NameValuePair;
import android.graphics.Color;
import com.nutiteq.projections.EPSG3857;
import com.nutiteq.components.MapPos;
import com.nutiteq.geometry.Geometry;
import com.nutiteq.geometry.Point;
import com.nutiteq.geometry.Line;
import com.nutiteq.geometry.Polygon;
import au.org.intersect.faims.android.nutiteq.GeometryStyle;
import au.org.intersect.faims.android.nutiteq.GeometryTextStyle;
import android.graphics.Typeface;
import au.org.intersect.faims.android.ui.map.QueryBuilder;
import au.org.intersect.faims.android.ui.map.LegacyQueryBuilder;

//========= Persist Functionalities ==========
/**
  * Persisting a beanshell object to store the value of the object name when the application is destroyed\n
  * and restore the value when the application is restored
  * @param name the name of the object
  */
persistObject(String name) {
	linker.setPersistedObjectName(name);
}

//========= Tab / Tab Group Functionalities ==========
/**
  * Showing the tab group with the label and clear all values if there was any value before in the tab group
  * @param label the label of the tab group
  */
newTabGroup(String label) {
	linker.newTabGroup(label);
}

/**
  * Showing the tab with the label and clear all values if there was any value before in the tab
  * @param label the label of the tab
  */
newTab(String label) {
	linker.newTab(label);
}

/**
  * Showing the tab group with the label and keep all values if there was any value before in the tab group
  * @param label the label of the tab group
  */
showTabGroup(String label){
    linker.showTabGroup(label);
}

/**
  * Showing the tab group with the label and load values for a given uuid to the tab group
  * @param id the reference of the tab group
  * @param uuid the id of the record
  */
showTabGroup(String id, String uuid){
    linker.showTabGroup(id,uuid);
}

/**
  * Showing the tab with the label and keep all values if there was any value before in the tab
  * @param label the label of the tab
  */
showTab(String label) {
	linker.showTab(label);
}

/**
  * Showing the tab with the label and load values for a given uuid to the tab
  * @param id the reference of the tab
  * @param uuid the id of the record
  */
showTab(String id, String uuid) {
	linker.showTab(id, uuid);
}

/**
  * Cancelling tab group will close the tab group. It will only give warning if the warning is set to be true\n
  * and if there is any changes in any field in the tab group
  * @param id the reference of the tab group
  * @param warn a boolean to set whether a warning dialog should appear or not
  */
cancelTabGroup(String id, boolean warn){
	linker.cancelTabGroup(id,warn);
}

/**
  * Cancelling tab will close the tab. It will only give warning if the warning is set to be true\n
  * and if there is any changes in any field in the tab
  * @param id the reference of the tab
  * @param warn a boolean to set whether a warning dialog should appear or not
  */
cancelTab(String id, boolean warn){
	linker.cancelTab(id,warn);
}

//========= Dialog Functionalities ==========
/**
  * Showing a toast to the user with the given message, the toast will last for about 1 second
  * @param message the message to be shown to the user
  */
showToast(String message) {
    linker.showToast(message);
}

/**
  * Showing an alert dialog to the user with the given message and a specific callback for ok and cancel buttons
  * @param title the title of the dialog
  * @param message the message to be shown to the user
  * @param okCallback the callback that is executed when OK button is pressed
  * @param cancelCallback the callback that is executed when cancel button is pressed
  */
showAlert(String title, String message, String okCallback, String cancelCallback){
    linker.showAlert(title, message, okCallback, cancelCallback);
}

/**
  * Showing a warning dialog to the user with the given message
  * @param title the title of the dialog
  * @param message the message to be shown to the user
  */
showWarning(String title, String message) {
	linker.showWarning(title, message);
}

//========= Setter / Getter Functionalities ==========
/**
  * Set value to the field that has the reference with given value. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param value the value to be set to the field, could be a collection, number, or String
  */
setFieldValue(String ref, Object value){
    linker.setFieldValue(ref, value);
}

/**
  * Set certainty to the field that has the reference with given value. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param value the value to be set to the field, could be a number or String
  */
setFieldCertainty(String ref, Object value){
    linker.setFieldCertainty(ref, value);
}

/**
  * Set annotation to the field that has the reference with given value. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param value the value to be set to the field, only accept String
  */
setFieldAnnotation(String ref, Object value){
    linker.setFieldAnnotation(ref, value);
}

/**
  * Get value of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the value of the field, could be collection or String
  */
Object getFieldValue(String ref){
    return linker.getFieldValue(ref);
}

/**
  * Get certainty of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the certainty of the field in String representation
  */
Object getFieldCertainty(String ref){
    return linker.getFieldCertainty(ref);
}

/**
  * Get annotation of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the annotation of the field in String representation
  */
Object getFieldAnnotation(String ref){
    return linker.getFieldAnnotation(ref);
}

/**
  * Get the current time of the application
  * @return the current time in String representation
  */
String getCurrentTime(){
    return linker.getCurrentTime();
}

/**
  * Clear the dirty button from the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  */
clearFieldDirty(String ref) {
	linker.setFieldDirty(ref, false, "");
}

//========= Event Callback Functionalities ==========
/**
  * Binding an event to the field that has the reference with a callback. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param type the type of event, one of click, show, or load
  * @param callback the callback that is executed when the binded field is on the set event
  */
onEvent(String ref, String type, String callback) {
	linker.bindViewToEvent(ref, type, callback);
}

/**
  * Binding a focus/blur event to the field that has the reference with a callback. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param focusCallback the callback that is executed when the field is on focus event
  * @param blurCallback the callback that is executed when the field is on blur event
  */
onFocus(String ref, String focusCallback, String blurCallback) {
	linker.bindFocusAndBlurEvent(ref, focusCallback, blurCallback);
}

//========= User Functionalities ==========
/**
  * Set the current user of the application, used to determine who creates the record.
  * @param user the user of the application
  */
setUser(User user){
	linker.setUser(user);
}

//========= Arch Ent / Relationship Functionalities ==========
/**
  * Saving arch entity into the database and return the entity_id of the saved entity
  * @param entity_id the id of the arch entity to be saved, might be null to save new entity
  * @param entity_type the type of the entity to be saved, must be coherent with the type specified in data schema
  * @param geo_data the list of geometries to be associated with the saved entity
  * @param attributes the list of attributes to be associated with the saved entity
  * @return the entity_id of the saved entity
  */
saveArchEnt(String entity_id, String entity_type, List geo_data, List attributes) {
	return linker.saveArchEnt(entity_id, entity_type, geo_data, attributes);
}

/**
  * Saving relationship into the database and return the rel_id of the saved relationship
  * @param rel_id the id of the relationship to be saved, might be null to save new relationship
  * @param rel_type the type of the relationship to be saved, must be coherent with the type specified in data schema
  * @param geo_data the list of geometries to be associated with the saved relationship
  * @param attributes the list of attributes to be associated with the saved relationship
  * @return the rel_id of the saved relationship
  */
saveRel(String rel_id, String rel_type, List geo_data, List attributes) {
	return linker.saveRel(rel_id, rel_type, geo_data, attributes);
}

/**
  * Add an arch entity to the relationship by specifying the verb as the relation.
  * @param entity_id the id of the arch entity to be associated with relationship
  * @param rel_id the id of the relationship to be associated to
  * @param verb the relation that is defined in the dataschema
  */
addReln(String entity_id, String rel_id, String verb) {
	linker.addReln(entity_id, rel_id, verb);
}

/**
  * Create attribute list to be saved to the entity/relationship
  * @return new attribute list
  */
createAttributeList() {
	return new ArrayList();
}

/**
  * Create entity attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the entity attribute, could be null
  * @param vocab the vocab of the entity attribute (obtained from the database), could be null
  * @param measure the measure of the entity attribute, could be null
  * @param certainty the certainty of the entity attribute, defaulted to 100% certainty
  * @return EntityAttribute
  */
createEntityAttribute(String name, String text, String vocab, String measure, String certainty){
	return createEntityAttribute(name, text, vocab, measure, certainty, false);
}

/**
  * Create entity attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the entity attribute, could be null
  * @param vocab the vocab of the entity attribute (obtained from the database), could be null
  * @param measure the measure of the entity attribute, could be null
  * @param certainty the certainty of the entity attribute, defaulted to 100% certainty
  * @param isDeleted set whether the entity attribute is deleted or not
  * @return EntityAttribute
  */
createEntityAttribute(String name, String text, String vocab, String measure, String certainty, boolean isDeleted) {
	EntityAttribute attribute = new EntityAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	attribute.setMeasure(measure);
	attribute.setCertainty(certainty);
	attribute.setDeleted(isDeleted);
	return attribute;
}

/**
  * Create relationship attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the relationship attribute, could be null
  * @param vocab the vocab of the relationship attribute (obtained from the database), could be null
  * @param certainty the certainty of the relationship attribute, defaulted to 100% certainty
  * @return RelationshipAttribute
  */
createRelationshipAttribute(String name, String text, String vocab, String certainty){
	return createRelationshipAttribute(name, text, vocab, certainty, false);
}

/**
  * Create relationship attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the relationship attribute, could be null
  * @param vocab the vocab of the relationship attribute (obtained from the database), could be null
  * @param certainty the certainty of the relationship attribute, defaulted to 100% certainty
  * @param isDeleted set whether the relationship attribute is deleted or not
  * @return RelationshipAttribute
  */
createRelationshipAttribute(String name, String text, String vocab, String certainty, boolean isDeleted) {
	RelationshipAttribute attribute = new RelationshipAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	attribute.setCertainty(certainty);
	attribute.setDeleted(isDeleted);
	return attribute;
}

/**
  * Populate dropdown from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the dropdown
  */
populateDropDown(String ref, Collection values){
    linker.populateDropDown(ref, values);
}

/**
  * Populate radio group from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the radio group
  */
populateRadioGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

/**
  * Populate checkbox from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the checkbox
  */
populateCheckBoxGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

/**
  * Populate list from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the list
  */
populateList(String ref, Collection values){
	linker.populateList(ref, values);
}

/**
  * Populate picture gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the picture gallery
  */
populatePictureGallery(String ref, Collection values){
	linker.populatePictureGallery(ref, values);
}

/**
  * Populate camera picture gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show picture\n
  * after taking picture from camera.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateCameraPictureGallery(String ref, Collection values){
	linker.populateCameraPictureGallery(ref, values);
}

/**
  * Populate video gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show video\n
  * after recording video.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateVideoGallery(String ref, Collection values){
	linker.populateVideoGallery(ref, values);
}

/**
  * Populate audio list from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show audio\n
  * after recording audio.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateAudioList(String ref, Collection values){
	linker.populateAudioList(ref, values);
}

/**
  * Fetching the data of arch entity with the given id, if the id is not found, a logic error dialog will appear
  * @param id the entity id of the arch entity
  * @return ArchEntity object or null
  */
Object fetchArchEnt(String id){
    return linker.fetchArchEnt(id);
}

/**
  * Fetching the data of relationship with the given id, if the id is not found, a logic error dialog will appear
  * @param id the entity id of the relationship
  * @return Relationship object or null
  */
Object fetchRel(String id){
    return linker.fetchRel(id);
}

/**
  * Fetching the data from the database by running query specified by user. It will only return one result.
  * @param query the query to be run against the database
  * @return Collection of String, might be empty
  */
Object fetchOne(String query){
    return linker.fetchOne(query);
}

/**
  * Fetching the data from the database by running query specified by user. It will return all result.
  * @param query the query to be run against the database
  * @return Collection of Collection of String, might be empty
  */
Collection fetchAll(String query){
    return linker.fetchAll(query);
}

/**
  * Fetching the list of arch entity to show to the user so the user can see what entities have been saved.
  * @param type the type of arch entity to be shown
  * @return Collection of Collection of String, might be empty
  */
Collection fetchEntityList(String type){
    return linker.fetchEntityList(type);
}

/**
  * Fetching the list of relationship to show to the user so the user can see what entities have been saved.
  * @param type the type of relationship to be shown
  * @return Collection of Collection of String, might be empty
  */
Collection fetchRelationshipList(String type){
    return linker.fetchRelationshipList(type);
}

/**
  * Get the selected value from the list to be used in the logic
  * @return _list_item_value of the selected value in the list
  */
String getListItemValue() {
	return _list_item_value;
}

//========= Navigation Functionalities ==========
/**
  * Provide functionality to go back as if the user press the hardware back button
  */
goBack(){
	linker.goBack();
}

//========= GPS Functionalities ==========
/**
  * Set the GPS update interval to determine how often the GPS should update, defaulted to 10 seconds
  * @param seconds the interval to be set
  */
setGPSUpdateInterval(int seconds){
	linker.setGpsUpdateInterval(seconds);
}

/**
  * Start using the internal GPS to update the location
  */
startInternalGPS(){
	linker.startInternalGPS();
}

/**
  * Start using the external GPS to update the location, it will bring up dialog to the user to choose\n
  * which bluetooth device to be used as external GPS
  */
startExternalGPS(){
	linker.startExternalGPS();
}

/**
  * Get the GPS position containing longitude and latitude from external GPS or internal GPS
  * @return GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPosition(){
	return linker.getGPSPosition();
}

/**
  * Get the GPS position containing longitude and latitude with the projection selected from external GPS or internal GPS
  * @return projected GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPositionProjected() {
	return linker.getGPSPositionProjected();
}

/**
  * Get the GPS accuracy from external GPS or internal GPS
  * @return accuracy of the gps or null
  */
Object getGPSEstimatedAccuracy(){
	return linker.getGPSEstimatedAccuracy();
}

/**
  * Get the GPS heading from external GPS or internal GPS
  * @return heading of the gps or null
  */
Object getGPSHeading(){
	return linker.getGPSHeading();
}

/**
  * Get the GPS position containing longitude and latitude from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPosition(String gps){
	return linker.getGPSPosition(gps);
}

/**
  * Get the GPS accuracy from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return accuracy of the selected gps or null
  */
Object getGPSEstimatedAccuracy(String gps){
	return linker.getGPSEstimatedAccuracy(gps);
}

/**
  * Get the GPS heading from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return heading of the selected gps or null
  */
Object getGPSHeading(String gps){
	return linker.getGPSHeading(gps);
}

/**
  * Start track log of the GPS and save it to the database so the user can look at the track log in the map
  * @param type either "distance" or "time"
  * @param value the value of the tracking, if type is "distance", the value will be in meter, if type is "time", the value will be in seconds
  */
startTrackingGPS(String type, int value){
	linker.startTrackingGPS(type, value);
}

/**
  * Stopping the track log of the GPS
  */
stopTrackingGPS(){
	linker.stopTrackingGPS();
}

//========= Map Functionalities ==========
/**
  * Binding map click event and vector click event to the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param clickCallback the call back that is executed when the map is clicked
  * @param selectCallback the call back that is executed when the vector element is clicked
  */
onMapEvent(String ref, String clickCallback, selectCallback) {
	linker.bindMapEvent(ref, clickCallback, selectCallback);
}

/**
  * Show raster map to the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing. The map will be the base map.
  * @param ref the reference to the map
  * @param layerName the layer name for the raster map
  * @param filename the filename of the map, will show error if the file does not exist
  */
showRasterMap(String ref, String layerName, String filename) {
	linker.showRasterMap(ref, layerName, filename);
}

/**
  * Set the focus point of the map that has the reference by specifying the float value of longitude and latitude.\n
  * If the map reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param longitude the longitude of the focus point
  * @param latitude the latitude of the focus point
  */
setMapFocusPoint(String ref, float longitude, float latitude) {
	linker.setMapFocusPoint(ref, longitude, latitude);
}

/**
  * Set the focus point of the map that has the reference by specifying the double value of longitude and latitude.\n
  * If the map reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param longitude the longitude of the focus point
  * @param latitude the latitude of the focus point
  */
setMapFocusPoint(String ref, double longitude, double latitude) {
	setMapFocusPoint(ref, (float) longitude, (float) latitude);
}

/**
  * Set the rotation of the map that has the reference by specifying the rotation value.\n
  * If the map reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param rotation the rotation of the map in degrees
  */
setMapRotation(String ref, float rotation) {
	linker.setMapRotation(ref, rotation);
}

/**
  * Set the zoom level of the map that has the reference by specifying the zoom value.\n
  * If the map reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param zoom the zoom value of the map
  */
setMapZoom(String ref, float zoom) {
	linker.setMapZoom(ref, zoom);
}

/**
  * Set the perspective view of the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param tilt the tilt value default is 90 degrees for 2d view, minimum is 30 degrees
  */
setMapTilt(String ref, float tilt) {
	linker.setMapTilt(ref, tilt);
}

/**
  * Show a shape layer to the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param layerName the layer name for the shape layer
  * @param filename the file path of the shape map, will show error if the file does not exist
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  */
showShapeLayer(String ref, String layerName, String filename, GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle) {
	linker.showShapeLayer(ref, layerName, filename, pointStyle, lineStyle, polygonStyle);
}

/**
  * Show a spatial layer to the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param layerName the layer name for the shape layer
  * @param filename the file path of the shape map, will show error if the file does not exist
  * @param tableName the table name to be loaded from the database
  * @param idColumn the id column from the table to be loaded from the database
  * @param labelColumn the label column from the table to be loaded from the database to be shown as the label
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  * @param textStyle the styling to all text labels appearing in the layer
  */
showSpatialLayer(String ref, String layerName, String filename, String tableName, String idColumn, String labelColumn, 
	GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle, GeometryTextStyle textStyle) {
	linker.showSpatialLayer(ref, layerName, filename, tableName, idColumn, labelColumn, pointStyle, lineStyle, polygonStyle, textStyle);
}

/**
  * Show a database layer to the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing. The layer shows all saved geometries in the database.
  * @param ref the reference to the map
  * @param layerName the layer name for the shape layer
  * @param isEntity a boolean value to determine whether it is entity or relationship
  * @param queryName the query name for the executed query
  * @param querySql the sql to be executed for the layer
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  * @param textStyle the styling to all text labels appearing in the layer
  */
showDatabaseLayer(String ref, String layerName, boolean isEntity, String queryName, String querySql,
	GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle, GeometryTextStyle textStyle) {
	linker.showDatabaseLayer(ref, layerName, isEntity, queryName, querySql, pointStyle, lineStyle, polygonStyle, textStyle);
}

/**
  * Remove a layer from the map that has the reference. If the map reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map
  * @param layerId the layerid to be removed, if not found, a logic error will appear.
  */
removeLayer(String ref, int layerId) {
	linker.removeLayer(ref, layerId);
}

centerOnCurrentPosition(String ref){
	linker.centerOnCurrentPosition(ref);
}

createCanvasLayer(String ref, String layerName) {
	return linker.createCanvasLayer(ref, layerName);
}

setLayerVisible(String ref, int layerId, boolean visible) {
	linker.setLayerVisible(ref, layerId, visible);
}

getMapPointClicked() {
	return _map_point_clicked;
}

drawPoint(String ref, int layerId, MapPos point, GeometryStyle style) {
	linker.drawPoint(ref, layerId, point, style);
}

drawLine(String ref, int layerId, List points, GeometryStyle style) {
	linker.drawLine(ref, layerId, points, style);
}

drawPolygon(String ref, int layerId, List points, GeometryStyle style) {
	linker.drawPolygon(ref, layerId, points, style);
}

clearGeometry(String ref, int geomId) {
	linker.clearGeometry(ref, geomId);
}

clearGeometryList(String ref, List geomList) {
	linker.clearGeometryList(ref, geomList);
}

createPoint(String lon, String lat) {
	return createPoint(Float.parseFloat(lon), Float.parseFloat(lat));
}

createPoint(float lon, float lat) {
	return new MapPos(lon, lat);
}

createPoint(double lon, double lat) {
	return createPoint((float) lon, (float) lat);
}

getGeometryList(String ref, int layerId) {
	return linker.getGeometryList(ref, layerId);
}

getGeometry(String ref, int geomId) {
	return linker.getGeometry(ref, geomId);
}

drawGeometry(String ref, int layerId, Geometry geom, GeometryStyle style) {
	if (geom instanceof Point) {
		return drawPoint(ref, layerId, ((Point) geom).getMapPos(), style);
	} else if (geom instanceof Line) {
		return drawLine(ref, layerId, ((Line) geom).getVertexList(), style);
	} else if (geom instanceof Polygon) {
		return drawPolygon(ref, layerId, ((Polygon) geom).getVertexList(), style);
	}
}

createPointStyle(int minZoom, int color, float size, float pickSize) {
	return linker.createPointStyle(minZoom, color, size, pickSize);
}

createLineStyle(int minZoom, int color, float width, float pickWidth, GeometryStyle pointStyle) {
	return linker.createLineStyle(minZoom, color, width, pickWidth, pointStyle);
}

createPolygonStyle(int minZoom, int color, GeometryStyle lineStyle) {
	return linker.createPolygonStyle(minZoom, color, lineStyle);
}

createTextStyle(int minZoom, int color, int size, android.graphics.Typeface font) {
	return linker.createTextStyle(minZoom, color, size, font);
}

lockMapView(String ref, boolean lock) {
	linker.lockMapView(ref, lock);
}

addGeometryHighlight(String ref, int geomId) {
	linker.addGeometryHighlight(ref, geomId);
}

removeGeometryHighlight(String ref, int geomId) {
	linker.removeGeometryHighlight(ref, geomId);
}

prepareHighlightTransform(String ref) {
	linker.prepareHighlightTransform(ref);
}

doHighlightTransform(String ref) {
	linker.doHighlightTransform(ref);
}

clearGeometryHighlights(String ref) {
	linker.clearGeometryHighlights(ref);
}

getGeometryHighlights(String ref) {
	return linker.getGeometryHighlights(ref);
}

getMapGeometrySelected() {
	return _map_geometry_selected;
}

addDatabaseLayerQuery(String ref, String name, String sql) {
	linker.addDatabaseLayerQuery(ref, name, sql);
}

addTrackLogLayerQuery(String ref, String name, String sql) {
	linker.addTrackLogLayerQuery(ref, name, sql);
}

addSelectQueryBuilder(String ref, String name, QueryBuilder builder) {
	linker.addSelectQueryBuilder(ref, name, builder);
}

createQueryBuilder(String sql) {
	return new QueryBuilder(sql);
}

addLegacySelectQueryBuilder(String ref, String name, String dbPath, String tableName, QueryBuilder builder) {
	linker.addLegacySelectQueryBuilder(ref, name, dbPath, tableName, builder);
}

createLegacyQueryBuilder(String sql) {
	return new LegacyQueryBuilder(sql);
}

convertFromProjToProj(String fromSrid, String toSrid, MapPos p) {
	return linker.convertFromProjToProj(fromSrid, toSrid, p);
}

setToolsEnabled(String ref, boolean enabled) {
	linker.setToolsEnabled(ref, enabled);
}

onToolEvent(String ref, String type, String callback) {
	linker.bindToolEvent(ref, type, callback);
}

getMapGeometryCreated() {
	return _map_geometry_created;
}

getMapGeometryLoaded() {
	return _map_geometry_loaded;
}

getMapGeometryLoadedType() {
	return _map_geometry_loaded_type;
}

refreshMap(String ref) {
	linker.refreshMap(ref);
}

//========= Sync Functionalities ==========
pushDatabaseToServer(String callback) {
	linker.pushDatabaseToServer(callback);
}

pullDatabaseFromServer(String callback) {
	linker.pullDatabaseFromServer(callback);
}

setSyncEnabled(boolean value) {
	linker.setSyncEnabled(value);
}

onSyncEvent(String startCallback, String successCallback, String failureCallback) {
	linker.addSyncListener(startCallback, successCallback, failureCallback);
}

setSyncMinInterval(float value) {
	linker.setSyncMinInterval(value);
}

setSyncMaxInterval(float value) {
	linker.setSyncMaxInterval(value);
}

setSyncDelay(float value) {
	linker.setSyncDelay(value);
}

setFileSyncEnabled(boolean enabled) {
	linker.setFileSyncEnabled(enabled);
}

//========= Static Data Functionalities ==========
String getProjectName(){
	return linker.getProjectName();
}

String getProjectSrid(){
	return linker.getProjectSrid();
}

String getProjectId(){
	return linker.getProjectId();
}

String getProjectSeason(){
	return linker.getProjectSeason();
}

String getProjectDescription(){
	return linker.getProjectDescription();
}

String getPermitNo(){
	return linker.getPermitNo();
}

String getPermitHolder(){
	return linker.getPermitHolder();
}

String getContactAndAddress(){
	return linker.getContactAndAddress();
}

String getParticipants(){
	return linker.getParticipants();
}

//========= File attachment Functionalities ==========
getLastSelectedFilename() {
	return _last_selected_filename;
}

getLastSelectedFilepath() {
	return _last_selected_filepath;
}

showFileBrowser(String callback) {
	linker.showFileBrowser(callback);
}

attachFile(String filePath, boolean sync, String dir) {
	return linker.attachFile(filePath, sync, dir);
}

viewArchEntAttachedFiles(String id){
	linker.viewArchEntAttachedFiles(id);
}

viewRelAttachedFiles(String id){
	linker.viewRelAttachedFiles(id);
}

attachFile(String filePath, boolean sync) {
	return linker.attachFile(filePath, sync, null);
}

openCamera(String callback){
	linker.openCamera(callback);
}

openVideo(String callback){
	linker.openVideo(callback);
}

recordAudio(String callback){
	linker.recordAudio(callback);
}

String getLastPictureFilePath(){
	return linker.getLastPictureFilePath();
}

String getLastVideoFilePath(){
	return linker.getLastVideoFilePath();
}

String getLastAudioFilePath(){
	return linker.getLastAudioFilePath();
}